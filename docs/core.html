<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ezduckdb.core API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ezduckdb.core</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os

from duckdb import connect
import pandas as pd
from sqlescapy import sqlescape
from string import Template
from typing import Mapping
from .paths import S3AwarePath


class SQL:
    &#34;&#34;&#34;A class for handling SQL queries with dynamic bindings.

    This class allows for the creation of SQL queries with variable bindings. It supports various data types for these bindings,
    including dataframes, nested SQL queries, strings, and primitive types. The class provides functionality to convert the query
    with its bindings to a string and to collect dataframes associated with the query.

    Parameters
    ----------
    sql : str
        The SQL query string with placeholders for bindings
    **bindings : dict
        Variable keyword arguments representing the bindings for the SQL query. The keys are the placeholder names in the SQL query,
        and the values are the actual values to be bound to these placeholders.

    Methods
    -------
    to_string() -&gt; str
        Converts the SQL query with its bindings to a string, with appropriate formatting and escaping of values.

    collect_dataframes() -&gt; Mapping[str, pd.DataFrame]
        Collects and returns a mapping of dataframe identifiers to their respective pandas DataFrame objects from the bindings.

    Raises
    ------
    AssertionError
        If a binding name does not exist in the SQL query.
    ValueError
        If a binding is of an invalid type that cannot be converted to a string representation for the SQL query.

    Notes
    -----
    - The method `to_string` handles different data types by converting them to their appropriate string representations in the SQL query.
      For instance, dataframes are represented by a unique identifier, and strings are escaped properly.
    - The method `collect_dataframes` is useful for retrieving the dataframes involved in the SQL query, especially when dealing with nested SQL queries.

    Examples
    --------
    &gt;&gt;&gt; query = SQL(&#34;SELECT * FROM users WHERE id = $id&#34;, id=123)
    &gt;&gt;&gt; print(query.to_string())
    &#34;SELECT * FROM users WHERE id = 123&#34;

    &gt;&gt;&gt; df = pd.DataFrame(...)
    &gt;&gt;&gt; query = SQL(&#34;INSERT INTO data VALUES $data&#34;, data=df)
    &gt;&gt;&gt; dfs = query.collect_dataframes()
    &gt;&gt;&gt; print(dfs)
    {&#39;df_&lt;unique_id_of_df&gt;&#39;: &lt;corresponding_dataframe&gt;}
    &#34;&#34;&#34;

    def __init__(self, sql, **bindings):
        for binding in bindings:
            assert binding in sql
        self.sql = sql
        self.bindings = bindings

    def to_string(self) -&gt; str:
        &#34;&#34;&#34;Converts the SQL query with its bindings into a string format.

        This method processes the SQL query and its associated bindings to generate a final query string.
        It handles various types of bindings: DataFrames are referenced by unique identifiers, nested SQL objects
        are recursively converted to strings, strings and file paths are escaped, and primitive types are directly converted.
        Unsupported types raise a ValueError.

        Returns
        -------
        str
            The formatted SQL query string with all bindings appropriately replaced.

        Raises
        ------
        ValueError
            If a binding is of an unsupported type that cannot be converted into a string representation.

        Examples
        --------
        &gt;&gt;&gt; query = SQL(&#34;SELECT * FROM data WHERE id = $id&#34;, id=123)
        &gt;&gt;&gt; print(query.to_string())
        &#34;SELECT * FROM data WHERE id = 123&#34;

        &gt;&gt;&gt; df = pd.DataFrame(...)
        &gt;&gt;&gt; nested_query = SQL(&#34;SELECT * FROM ($subquery) AS sub&#34;, subquery=SQL(&#34;SELECT * FROM data&#34;))
        &gt;&gt;&gt; print(nested_query.to_string())
        &#34;SELECT * FROM (SELECT * FROM data) AS sub&#34;
        &#34;&#34;&#34;
        replacements = {}
        for key, value in self.bindings.items():
            if isinstance(value, pd.DataFrame):
                replacements[key] = f&#34;df_{id(value)}&#34;
            elif isinstance(value, SQL):
                replacements[key] = f&#34;({value.to_string()})&#34;
            elif isinstance(value, (str, S3AwarePath)):
                replacements[key] = f&#34;&#39;{sqlescape(value)}&#39;&#34;
            elif isinstance(value, (int, float, bool)):
                replacements[key] = str(value)
            elif value is None:
                replacements[key] = &#34;null&#34;
            else:
                raise ValueError(f&#34;Invalid type for {key}&#34;)
        return Template(self.sql).safe_substitute(replacements)

    def collect_dataframes(self) -&gt; Mapping[str, pd.DataFrame]:
        &#34;&#34;&#34;
        Collects and returns dataframes associated with the SQL bindings.

        This method iterates through the bindings of the SQL object to find and collect all pandas DataFrame objects.
        It also recursively collects dataframes from nested SQL objects. The dataframes are returned as a dictionary
        mapping unique identifiers (generated from the dataframe&#39;s memory addresses) to the dataframe objects.

        Returns
        -------
        Mapping[str, pd.DataFrame]
            A dictionary mapping unique identifiers to pandas DataFrame objects present in the SQL bindings.

        Examples
        --------
        &gt;&gt;&gt; df1 = pd.DataFrame(...)
        &gt;&gt;&gt; df2 = pd.DataFrame(...)
        &gt;&gt;&gt; query = SQL(&#34;SELECT * FROM $df1 left join $df2 using(id)&#34;, df1=df1, df2=df2)
        &gt;&gt;&gt; dfs = query.collect_dataframes()
        &gt;&gt;&gt; for key in dfs:
        ...     print(f&#34;{key}: {type(dfs[key])}&#34;)
        df_&lt;unique_id_of_df1&gt;: &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
        df_&lt;unique_id_of_df2&gt;: &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
        &#34;&#34;&#34;
        dataframes = {}
        for key, value in self.bindings.items():
            if isinstance(value, pd.DataFrame):
                dataframes[f&#34;df_{id(value)}&#34;] = value
            elif isinstance(value, SQL):
                dataframes.update(value.collect_dataframes())
        return dataframes


class DuckDB:
    &#34;&#34;&#34;A class for managing connections and queries to a DuckDB database.

    This class provides an interface for connecting to a DuckDB database,
    executing queries, and managing the database connection. It supports
    integration with S3 storage using AWS credentials.

    Parameters
    ----------
    options : str, optional
        Additional options for the database connection, by default &#34;&#34;.
    db_location : str, optional
        The location of the database. Use &#39;:memory:&#39; for in-memory database,
        by default &#34;:memory:&#34;.
    aws_profile: str, optional
        Indicates the profile to use for aws authentication.
    aws_profile : str, optional
        The AWS profile name to be used for aws authentication.

    Notes
    ----------
    - Pick aws_profile or aws_env_vars. Not both.

    Attributes
    ----------
    options : str
        Options for the database connection.
    db_location : str
        The location of the DuckDB database.
    s3_storage_used : bool
        Flag to determine the usage of S3 storage.
    aws_profile : str
        The AWS profile name for accessing S3 storage.

    &#34;&#34;&#34;

    def __init__(
        self, options=&#34;&#34;, db_location=&#34;:memory:&#34;, aws_profile=None, aws_env_vars=False
    ):
        self.options = options
        self.db_location = db_location
        self.aws_profile = aws_profile
        self.aws_env_vars = aws_env_vars

        if aws_profile and aws_env_vars:
            raise ValueError(
                &#34;Cannot specify both aws_profile and aws_env_vars. Pick one.&#34;
            )

    def connect(self):
        &#34;&#34;&#34;
        Establishes a connection to the DuckDB database.

        This method sets up the database connection based on the initialized
        parameters. If S3 storage is used, it installs and loads necessary
        extensions and sets the AWS credentials.

        Notes
        -----
        -  It is recommended to use the context manager or query method instead for most uses.

        Returns
        -------
        connection
            The connection object to the DuckDB database.

        Examples
        --------
        &gt;&gt;&gt; duckdb_instance = DuckDB()
        &gt;&gt;&gt; connection = duckdb_instance.connect()
        &#34;&#34;&#34;
        connection = connect(self.db_location)
        if self.aws_profile or self.aws_env_vars:
            connection.query(&#34;install httpfs; load httpfs;&#34;)
            connection.query(&#34;install aws; load aws;&#34;)
            if self.aws_env_vars:
                connection.query(&#34;CALL load_aws_credentials();&#34;)
            else:
                connection.query(f&#34;CALL load_aws_credentials(&#39;{self.aws_profile}&#39;);&#34;)
        connection.query(self.options)
        return connection

    def query(self, select_statement: SQL):
        &#34;&#34;&#34;Executes a SQL query on the DuckDB database.

        This method connects to the database, registers dataframes from the
        provided SQL statement, and then executes the query.

        Parameters
        ----------
        select_statement : SQL
            An SQL object representing the SQL query to be executed.

        Returns
        -------
        DataFrame or None
            A pandas DataFrame containing the result of the query, or None
            if there is no result.

        Examples
        --------
        &gt;&gt;&gt; duckdb_instance = DuckDB()
        &gt;&gt;&gt; df = pd.DataFrame(...)
        &gt;&gt;&gt; result = duckdb_instance.query(SQL(&#34;SELECT $value FROM $df&#34;,value=123,df=df))
        &#34;&#34;&#34;
        db = self.connect()
        dataframes = select_statement.collect_dataframes()
        for key, value in dataframes.items():
            db.register(key, value)

        result = db.query(select_statement.to_string())
        if result is None:
            return
        return result.df()

    def __enter__(self):
        &#34;&#34;&#34;Connects to the DuckDB database.

        The `with` statement will bind a duckdb connect return to
        the target specified in the as clause of the statement.

        Returns
        -------
        connection
            The connection object to the DuckDB database.

        Examples
        --------
        &gt;&gt;&gt; with DuckDB() as connection:
        ...     # db is a connected database instance
        ...     result = connection.query(&#34;SELECT COUNT(*) FROM my_table;&#34;)
        &#34;&#34;&#34;
        self.connection = self.connect()
        return self.connection

    def __exit__(self, exc_type, exc_value, exc_tb):
        &#34;&#34;&#34;Exit the runtime context and close the database connection.

        Parameters
        ----------
        exc_type : Exception or None
            The type of the exception that caused the context to be exited.
        exc_value : Exception or None
            The exception that caused the context to be exited.
        exc_tb : Traceback or Non e
            A traceback object.

        Examples
        --------
        &gt;&gt;&gt; with DuckDB() as connection:
        ...     # Operations with db
        ... # Automatic closure of db connection occurs here
        &#34;&#34;&#34;
        self.connection.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ezduckdb.core.DuckDB"><code class="flex name class">
<span>class <span class="ident">DuckDB</span></span>
<span>(</span><span>options='', db_location=':memory:', aws_profile=None, aws_env_vars=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for managing connections and queries to a DuckDB database.</p>
<p>This class provides an interface for connecting to a DuckDB database,
executing queries, and managing the database connection. It supports
integration with S3 storage using AWS credentials.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Additional options for the database connection, by default "".</dd>
<dt><strong><code>db_location</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The location of the database. Use ':memory:' for in-memory database,
by default ":memory:".</dd>
<dt><strong><code>aws_profile</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Indicates the profile to use for aws authentication.</dd>
<dt><strong><code>aws_profile</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The AWS profile name to be used for aws authentication.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Pick aws_profile or aws_env_vars. Not both.</li>
</ul>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>str</code></dt>
<dd>Options for the database connection.</dd>
<dt><strong><code>db_location</code></strong> :&ensp;<code>str</code></dt>
<dd>The location of the DuckDB database.</dd>
<dt><strong><code>s3_storage_used</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to determine the usage of S3 storage.</dd>
<dt><strong><code>aws_profile</code></strong> :&ensp;<code>str</code></dt>
<dd>The AWS profile name for accessing S3 storage.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DuckDB:
    &#34;&#34;&#34;A class for managing connections and queries to a DuckDB database.

    This class provides an interface for connecting to a DuckDB database,
    executing queries, and managing the database connection. It supports
    integration with S3 storage using AWS credentials.

    Parameters
    ----------
    options : str, optional
        Additional options for the database connection, by default &#34;&#34;.
    db_location : str, optional
        The location of the database. Use &#39;:memory:&#39; for in-memory database,
        by default &#34;:memory:&#34;.
    aws_profile: str, optional
        Indicates the profile to use for aws authentication.
    aws_profile : str, optional
        The AWS profile name to be used for aws authentication.

    Notes
    ----------
    - Pick aws_profile or aws_env_vars. Not both.

    Attributes
    ----------
    options : str
        Options for the database connection.
    db_location : str
        The location of the DuckDB database.
    s3_storage_used : bool
        Flag to determine the usage of S3 storage.
    aws_profile : str
        The AWS profile name for accessing S3 storage.

    &#34;&#34;&#34;

    def __init__(
        self, options=&#34;&#34;, db_location=&#34;:memory:&#34;, aws_profile=None, aws_env_vars=False
    ):
        self.options = options
        self.db_location = db_location
        self.aws_profile = aws_profile
        self.aws_env_vars = aws_env_vars

        if aws_profile and aws_env_vars:
            raise ValueError(
                &#34;Cannot specify both aws_profile and aws_env_vars. Pick one.&#34;
            )

    def connect(self):
        &#34;&#34;&#34;
        Establishes a connection to the DuckDB database.

        This method sets up the database connection based on the initialized
        parameters. If S3 storage is used, it installs and loads necessary
        extensions and sets the AWS credentials.

        Notes
        -----
        -  It is recommended to use the context manager or query method instead for most uses.

        Returns
        -------
        connection
            The connection object to the DuckDB database.

        Examples
        --------
        &gt;&gt;&gt; duckdb_instance = DuckDB()
        &gt;&gt;&gt; connection = duckdb_instance.connect()
        &#34;&#34;&#34;
        connection = connect(self.db_location)
        if self.aws_profile or self.aws_env_vars:
            connection.query(&#34;install httpfs; load httpfs;&#34;)
            connection.query(&#34;install aws; load aws;&#34;)
            if self.aws_env_vars:
                connection.query(&#34;CALL load_aws_credentials();&#34;)
            else:
                connection.query(f&#34;CALL load_aws_credentials(&#39;{self.aws_profile}&#39;);&#34;)
        connection.query(self.options)
        return connection

    def query(self, select_statement: SQL):
        &#34;&#34;&#34;Executes a SQL query on the DuckDB database.

        This method connects to the database, registers dataframes from the
        provided SQL statement, and then executes the query.

        Parameters
        ----------
        select_statement : SQL
            An SQL object representing the SQL query to be executed.

        Returns
        -------
        DataFrame or None
            A pandas DataFrame containing the result of the query, or None
            if there is no result.

        Examples
        --------
        &gt;&gt;&gt; duckdb_instance = DuckDB()
        &gt;&gt;&gt; df = pd.DataFrame(...)
        &gt;&gt;&gt; result = duckdb_instance.query(SQL(&#34;SELECT $value FROM $df&#34;,value=123,df=df))
        &#34;&#34;&#34;
        db = self.connect()
        dataframes = select_statement.collect_dataframes()
        for key, value in dataframes.items():
            db.register(key, value)

        result = db.query(select_statement.to_string())
        if result is None:
            return
        return result.df()

    def __enter__(self):
        &#34;&#34;&#34;Connects to the DuckDB database.

        The `with` statement will bind a duckdb connect return to
        the target specified in the as clause of the statement.

        Returns
        -------
        connection
            The connection object to the DuckDB database.

        Examples
        --------
        &gt;&gt;&gt; with DuckDB() as connection:
        ...     # db is a connected database instance
        ...     result = connection.query(&#34;SELECT COUNT(*) FROM my_table;&#34;)
        &#34;&#34;&#34;
        self.connection = self.connect()
        return self.connection

    def __exit__(self, exc_type, exc_value, exc_tb):
        &#34;&#34;&#34;Exit the runtime context and close the database connection.

        Parameters
        ----------
        exc_type : Exception or None
            The type of the exception that caused the context to be exited.
        exc_value : Exception or None
            The exception that caused the context to be exited.
        exc_tb : Traceback or Non e
            A traceback object.

        Examples
        --------
        &gt;&gt;&gt; with DuckDB() as connection:
        ...     # Operations with db
        ... # Automatic closure of db connection occurs here
        &#34;&#34;&#34;
        self.connection.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ezduckdb.core.DuckDB.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Establishes a connection to the DuckDB database.</p>
<p>This method sets up the database connection based on the initialized
parameters. If S3 storage is used, it installs and loads necessary
extensions and sets the AWS credentials.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>It is recommended to use the context manager or query method instead for most uses.</li>
</ul>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>connection</code></dt>
<dd>The connection object to the DuckDB database.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; duckdb_instance = DuckDB()
&gt;&gt;&gt; connection = duckdb_instance.connect()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;
    Establishes a connection to the DuckDB database.

    This method sets up the database connection based on the initialized
    parameters. If S3 storage is used, it installs and loads necessary
    extensions and sets the AWS credentials.

    Notes
    -----
    -  It is recommended to use the context manager or query method instead for most uses.

    Returns
    -------
    connection
        The connection object to the DuckDB database.

    Examples
    --------
    &gt;&gt;&gt; duckdb_instance = DuckDB()
    &gt;&gt;&gt; connection = duckdb_instance.connect()
    &#34;&#34;&#34;
    connection = connect(self.db_location)
    if self.aws_profile or self.aws_env_vars:
        connection.query(&#34;install httpfs; load httpfs;&#34;)
        connection.query(&#34;install aws; load aws;&#34;)
        if self.aws_env_vars:
            connection.query(&#34;CALL load_aws_credentials();&#34;)
        else:
            connection.query(f&#34;CALL load_aws_credentials(&#39;{self.aws_profile}&#39;);&#34;)
    connection.query(self.options)
    return connection</code></pre>
</details>
</dd>
<dt id="ezduckdb.core.DuckDB.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self, select_statement: <a title="ezduckdb.core.SQL" href="#ezduckdb.core.SQL">SQL</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a SQL query on the DuckDB database.</p>
<p>This method connects to the database, registers dataframes from the
provided SQL statement, and then executes the query.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>select_statement</code></strong> :&ensp;<code><a title="ezduckdb.core.SQL" href="#ezduckdb.core.SQL">SQL</a></code></dt>
<dd>An SQL object representing the SQL query to be executed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code> or <code>None</code></dt>
<dd>A pandas DataFrame containing the result of the query, or None
if there is no result.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; duckdb_instance = DuckDB()
&gt;&gt;&gt; df = pd.DataFrame(...)
&gt;&gt;&gt; result = duckdb_instance.query(SQL(&quot;SELECT $value FROM $df&quot;,value=123,df=df))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query(self, select_statement: SQL):
    &#34;&#34;&#34;Executes a SQL query on the DuckDB database.

    This method connects to the database, registers dataframes from the
    provided SQL statement, and then executes the query.

    Parameters
    ----------
    select_statement : SQL
        An SQL object representing the SQL query to be executed.

    Returns
    -------
    DataFrame or None
        A pandas DataFrame containing the result of the query, or None
        if there is no result.

    Examples
    --------
    &gt;&gt;&gt; duckdb_instance = DuckDB()
    &gt;&gt;&gt; df = pd.DataFrame(...)
    &gt;&gt;&gt; result = duckdb_instance.query(SQL(&#34;SELECT $value FROM $df&#34;,value=123,df=df))
    &#34;&#34;&#34;
    db = self.connect()
    dataframes = select_statement.collect_dataframes()
    for key, value in dataframes.items():
        db.register(key, value)

    result = db.query(select_statement.to_string())
    if result is None:
        return
    return result.df()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ezduckdb.core.SQL"><code class="flex name class">
<span>class <span class="ident">SQL</span></span>
<span>(</span><span>sql, **bindings)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for handling SQL queries with dynamic bindings.</p>
<p>This class allows for the creation of SQL queries with variable bindings. It supports various data types for these bindings,
including dataframes, nested SQL queries, strings, and primitive types. The class provides functionality to convert the query
with its bindings to a string and to collect dataframes associated with the query.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sql</code></strong> :&ensp;<code>str</code></dt>
<dd>The SQL query string with placeholders for bindings</dd>
<dt><strong><code>**bindings</code></strong> :&ensp;<code>dict</code></dt>
<dd>Variable keyword arguments representing the bindings for the SQL query. The keys are the placeholder names in the SQL query,
and the values are the actual values to be bound to these placeholders.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>to_string() -&gt; str
Converts the SQL query with its bindings to a string, with appropriate formatting and escaping of values.</p>
<p>collect_dataframes() -&gt; Mapping[str, pd.DataFrame]
Collects and returns a mapping of dataframe identifiers to their respective pandas DataFrame objects from the bindings.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AssertionError</code></dt>
<dd>If a binding name does not exist in the SQL query.</dd>
<dt><code>ValueError</code></dt>
<dd>If a binding is of an invalid type that cannot be converted to a string representation for the SQL query.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>The method <code>to_string</code> handles different data types by converting them to their appropriate string representations in the SQL query.
For instance, dataframes are represented by a unique identifier, and strings are escaped properly.</li>
<li>The method <code>collect_dataframes</code> is useful for retrieving the dataframes involved in the SQL query, especially when dealing with nested SQL queries.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; query = SQL(&quot;SELECT * FROM users WHERE id = $id&quot;, id=123)
&gt;&gt;&gt; print(query.to_string())
&quot;SELECT * FROM users WHERE id = 123&quot;
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; df = pd.DataFrame(...)
&gt;&gt;&gt; query = SQL(&quot;INSERT INTO data VALUES $data&quot;, data=df)
&gt;&gt;&gt; dfs = query.collect_dataframes()
&gt;&gt;&gt; print(dfs)
{'df_&lt;unique_id_of_df&gt;': &lt;corresponding_dataframe&gt;}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SQL:
    &#34;&#34;&#34;A class for handling SQL queries with dynamic bindings.

    This class allows for the creation of SQL queries with variable bindings. It supports various data types for these bindings,
    including dataframes, nested SQL queries, strings, and primitive types. The class provides functionality to convert the query
    with its bindings to a string and to collect dataframes associated with the query.

    Parameters
    ----------
    sql : str
        The SQL query string with placeholders for bindings
    **bindings : dict
        Variable keyword arguments representing the bindings for the SQL query. The keys are the placeholder names in the SQL query,
        and the values are the actual values to be bound to these placeholders.

    Methods
    -------
    to_string() -&gt; str
        Converts the SQL query with its bindings to a string, with appropriate formatting and escaping of values.

    collect_dataframes() -&gt; Mapping[str, pd.DataFrame]
        Collects and returns a mapping of dataframe identifiers to their respective pandas DataFrame objects from the bindings.

    Raises
    ------
    AssertionError
        If a binding name does not exist in the SQL query.
    ValueError
        If a binding is of an invalid type that cannot be converted to a string representation for the SQL query.

    Notes
    -----
    - The method `to_string` handles different data types by converting them to their appropriate string representations in the SQL query.
      For instance, dataframes are represented by a unique identifier, and strings are escaped properly.
    - The method `collect_dataframes` is useful for retrieving the dataframes involved in the SQL query, especially when dealing with nested SQL queries.

    Examples
    --------
    &gt;&gt;&gt; query = SQL(&#34;SELECT * FROM users WHERE id = $id&#34;, id=123)
    &gt;&gt;&gt; print(query.to_string())
    &#34;SELECT * FROM users WHERE id = 123&#34;

    &gt;&gt;&gt; df = pd.DataFrame(...)
    &gt;&gt;&gt; query = SQL(&#34;INSERT INTO data VALUES $data&#34;, data=df)
    &gt;&gt;&gt; dfs = query.collect_dataframes()
    &gt;&gt;&gt; print(dfs)
    {&#39;df_&lt;unique_id_of_df&gt;&#39;: &lt;corresponding_dataframe&gt;}
    &#34;&#34;&#34;

    def __init__(self, sql, **bindings):
        for binding in bindings:
            assert binding in sql
        self.sql = sql
        self.bindings = bindings

    def to_string(self) -&gt; str:
        &#34;&#34;&#34;Converts the SQL query with its bindings into a string format.

        This method processes the SQL query and its associated bindings to generate a final query string.
        It handles various types of bindings: DataFrames are referenced by unique identifiers, nested SQL objects
        are recursively converted to strings, strings and file paths are escaped, and primitive types are directly converted.
        Unsupported types raise a ValueError.

        Returns
        -------
        str
            The formatted SQL query string with all bindings appropriately replaced.

        Raises
        ------
        ValueError
            If a binding is of an unsupported type that cannot be converted into a string representation.

        Examples
        --------
        &gt;&gt;&gt; query = SQL(&#34;SELECT * FROM data WHERE id = $id&#34;, id=123)
        &gt;&gt;&gt; print(query.to_string())
        &#34;SELECT * FROM data WHERE id = 123&#34;

        &gt;&gt;&gt; df = pd.DataFrame(...)
        &gt;&gt;&gt; nested_query = SQL(&#34;SELECT * FROM ($subquery) AS sub&#34;, subquery=SQL(&#34;SELECT * FROM data&#34;))
        &gt;&gt;&gt; print(nested_query.to_string())
        &#34;SELECT * FROM (SELECT * FROM data) AS sub&#34;
        &#34;&#34;&#34;
        replacements = {}
        for key, value in self.bindings.items():
            if isinstance(value, pd.DataFrame):
                replacements[key] = f&#34;df_{id(value)}&#34;
            elif isinstance(value, SQL):
                replacements[key] = f&#34;({value.to_string()})&#34;
            elif isinstance(value, (str, S3AwarePath)):
                replacements[key] = f&#34;&#39;{sqlescape(value)}&#39;&#34;
            elif isinstance(value, (int, float, bool)):
                replacements[key] = str(value)
            elif value is None:
                replacements[key] = &#34;null&#34;
            else:
                raise ValueError(f&#34;Invalid type for {key}&#34;)
        return Template(self.sql).safe_substitute(replacements)

    def collect_dataframes(self) -&gt; Mapping[str, pd.DataFrame]:
        &#34;&#34;&#34;
        Collects and returns dataframes associated with the SQL bindings.

        This method iterates through the bindings of the SQL object to find and collect all pandas DataFrame objects.
        It also recursively collects dataframes from nested SQL objects. The dataframes are returned as a dictionary
        mapping unique identifiers (generated from the dataframe&#39;s memory addresses) to the dataframe objects.

        Returns
        -------
        Mapping[str, pd.DataFrame]
            A dictionary mapping unique identifiers to pandas DataFrame objects present in the SQL bindings.

        Examples
        --------
        &gt;&gt;&gt; df1 = pd.DataFrame(...)
        &gt;&gt;&gt; df2 = pd.DataFrame(...)
        &gt;&gt;&gt; query = SQL(&#34;SELECT * FROM $df1 left join $df2 using(id)&#34;, df1=df1, df2=df2)
        &gt;&gt;&gt; dfs = query.collect_dataframes()
        &gt;&gt;&gt; for key in dfs:
        ...     print(f&#34;{key}: {type(dfs[key])}&#34;)
        df_&lt;unique_id_of_df1&gt;: &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
        df_&lt;unique_id_of_df2&gt;: &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
        &#34;&#34;&#34;
        dataframes = {}
        for key, value in self.bindings.items():
            if isinstance(value, pd.DataFrame):
                dataframes[f&#34;df_{id(value)}&#34;] = value
            elif isinstance(value, SQL):
                dataframes.update(value.collect_dataframes())
        return dataframes</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ezduckdb.core.SQL.collect_dataframes"><code class="name flex">
<span>def <span class="ident">collect_dataframes</span></span>(<span>self) ‑> Mapping[str, pandas.core.frame.DataFrame]</span>
</code></dt>
<dd>
<div class="desc"><p>Collects and returns dataframes associated with the SQL bindings.</p>
<p>This method iterates through the bindings of the SQL object to find and collect all pandas DataFrame objects.
It also recursively collects dataframes from nested SQL objects. The dataframes are returned as a dictionary
mapping unique identifiers (generated from the dataframe's memory addresses) to the dataframe objects.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Mapping[str, pd.DataFrame]</code></dt>
<dd>A dictionary mapping unique identifiers to pandas DataFrame objects present in the SQL bindings.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; df1 = pd.DataFrame(...)
&gt;&gt;&gt; df2 = pd.DataFrame(...)
&gt;&gt;&gt; query = SQL(&quot;SELECT * FROM $df1 left join $df2 using(id)&quot;, df1=df1, df2=df2)
&gt;&gt;&gt; dfs = query.collect_dataframes()
&gt;&gt;&gt; for key in dfs:
...     print(f&quot;{key}: {type(dfs[key])}&quot;)
df_&lt;unique_id_of_df1&gt;: &lt;class 'pandas.core.frame.DataFrame'&gt;
df_&lt;unique_id_of_df2&gt;: &lt;class 'pandas.core.frame.DataFrame'&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_dataframes(self) -&gt; Mapping[str, pd.DataFrame]:
    &#34;&#34;&#34;
    Collects and returns dataframes associated with the SQL bindings.

    This method iterates through the bindings of the SQL object to find and collect all pandas DataFrame objects.
    It also recursively collects dataframes from nested SQL objects. The dataframes are returned as a dictionary
    mapping unique identifiers (generated from the dataframe&#39;s memory addresses) to the dataframe objects.

    Returns
    -------
    Mapping[str, pd.DataFrame]
        A dictionary mapping unique identifiers to pandas DataFrame objects present in the SQL bindings.

    Examples
    --------
    &gt;&gt;&gt; df1 = pd.DataFrame(...)
    &gt;&gt;&gt; df2 = pd.DataFrame(...)
    &gt;&gt;&gt; query = SQL(&#34;SELECT * FROM $df1 left join $df2 using(id)&#34;, df1=df1, df2=df2)
    &gt;&gt;&gt; dfs = query.collect_dataframes()
    &gt;&gt;&gt; for key in dfs:
    ...     print(f&#34;{key}: {type(dfs[key])}&#34;)
    df_&lt;unique_id_of_df1&gt;: &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    df_&lt;unique_id_of_df2&gt;: &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    &#34;&#34;&#34;
    dataframes = {}
    for key, value in self.bindings.items():
        if isinstance(value, pd.DataFrame):
            dataframes[f&#34;df_{id(value)}&#34;] = value
        elif isinstance(value, SQL):
            dataframes.update(value.collect_dataframes())
    return dataframes</code></pre>
</details>
</dd>
<dt id="ezduckdb.core.SQL.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the SQL query with its bindings into a string format.</p>
<p>This method processes the SQL query and its associated bindings to generate a final query string.
It handles various types of bindings: DataFrames are referenced by unique identifiers, nested SQL objects
are recursively converted to strings, strings and file paths are escaped, and primitive types are directly converted.
Unsupported types raise a ValueError.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted SQL query string with all bindings appropriately replaced.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a binding is of an unsupported type that cannot be converted into a string representation.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; query = SQL(&quot;SELECT * FROM data WHERE id = $id&quot;, id=123)
&gt;&gt;&gt; print(query.to_string())
&quot;SELECT * FROM data WHERE id = 123&quot;
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; df = pd.DataFrame(...)
&gt;&gt;&gt; nested_query = SQL(&quot;SELECT * FROM ($subquery) AS sub&quot;, subquery=SQL(&quot;SELECT * FROM data&quot;))
&gt;&gt;&gt; print(nested_query.to_string())
&quot;SELECT * FROM (SELECT * FROM data) AS sub&quot;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_string(self) -&gt; str:
    &#34;&#34;&#34;Converts the SQL query with its bindings into a string format.

    This method processes the SQL query and its associated bindings to generate a final query string.
    It handles various types of bindings: DataFrames are referenced by unique identifiers, nested SQL objects
    are recursively converted to strings, strings and file paths are escaped, and primitive types are directly converted.
    Unsupported types raise a ValueError.

    Returns
    -------
    str
        The formatted SQL query string with all bindings appropriately replaced.

    Raises
    ------
    ValueError
        If a binding is of an unsupported type that cannot be converted into a string representation.

    Examples
    --------
    &gt;&gt;&gt; query = SQL(&#34;SELECT * FROM data WHERE id = $id&#34;, id=123)
    &gt;&gt;&gt; print(query.to_string())
    &#34;SELECT * FROM data WHERE id = 123&#34;

    &gt;&gt;&gt; df = pd.DataFrame(...)
    &gt;&gt;&gt; nested_query = SQL(&#34;SELECT * FROM ($subquery) AS sub&#34;, subquery=SQL(&#34;SELECT * FROM data&#34;))
    &gt;&gt;&gt; print(nested_query.to_string())
    &#34;SELECT * FROM (SELECT * FROM data) AS sub&#34;
    &#34;&#34;&#34;
    replacements = {}
    for key, value in self.bindings.items():
        if isinstance(value, pd.DataFrame):
            replacements[key] = f&#34;df_{id(value)}&#34;
        elif isinstance(value, SQL):
            replacements[key] = f&#34;({value.to_string()})&#34;
        elif isinstance(value, (str, S3AwarePath)):
            replacements[key] = f&#34;&#39;{sqlescape(value)}&#39;&#34;
        elif isinstance(value, (int, float, bool)):
            replacements[key] = str(value)
        elif value is None:
            replacements[key] = &#34;null&#34;
        else:
            raise ValueError(f&#34;Invalid type for {key}&#34;)
    return Template(self.sql).safe_substitute(replacements)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ezduckdb" href="index.html">ezduckdb</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ezduckdb.core.DuckDB" href="#ezduckdb.core.DuckDB">DuckDB</a></code></h4>
<ul class="">
<li><code><a title="ezduckdb.core.DuckDB.connect" href="#ezduckdb.core.DuckDB.connect">connect</a></code></li>
<li><code><a title="ezduckdb.core.DuckDB.query" href="#ezduckdb.core.DuckDB.query">query</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ezduckdb.core.SQL" href="#ezduckdb.core.SQL">SQL</a></code></h4>
<ul class="">
<li><code><a title="ezduckdb.core.SQL.collect_dataframes" href="#ezduckdb.core.SQL.collect_dataframes">collect_dataframes</a></code></li>
<li><code><a title="ezduckdb.core.SQL.to_string" href="#ezduckdb.core.SQL.to_string">to_string</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>